/**
 * Copyright (c) 2020, ETH Zurich, Computer Engineering Group
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * initiates GPIO sampling with PRU1
 *
 * usage:
 *          ./fl_logic [filename] [starttime]
 *
 * filename     (optional) output filename
 * starttime    (optional) UNIX timestamp of the sampling start
 * 
 * Note: starttime needs to be the 2nd argument, i.e. only works in conjunction with a filename.
 *
 */

// INCLUDES
#include <errno.h>
#include <stdbool.h>
#include <string.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <signal.h>
#include <pruss_intc_mapping.h>
#include <prussdrv.h>
#include <time.h>
#include <sys/stat.h>
#include <unistd.h>


// DEFINES
#ifndef INTERACTIVE_MODE
 #define INTERACTIVE_MODE     0
#endif /* INTERACTIVE_MODE */
#if INTERACTIVE_MODE
 #define BUFFER_SIZE          8                     // in bytes (must be a power of 2, minimum is 8 bytes)
#else
 #define BUFFER_SIZE          4096
#endif
#define SAMPLING_RATE         1000000               // must match the sampling rate of the PRU
#define PRU1_FIRMWARE         "/lib/firmware/fl_pru1_logic.bin"     // must be a binary file
#define DATA_FILENAME_PREFIX  "tracing_data"
#define OUTPUT_DIR            "/home/flocklab/data/"                // with last slash
#define SPRINTF_BUFFER_LENGTH 256
#define PIN_NAMES             "LED1", "LED2", "LED3", "INT1", "INT2", "SIG1", "SIG2", "nRST"


// PARAMETER CHECK
#if (BUFFER_SIZE & (BUFFER_SIZE - 1)) || (BUFFER_SIZE < 8)
#error "invalid BUFFER_SIZE"
#endif


// MACROS
#define BYTE_TO_BIN_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BIN(byte)   (byte & 0x80 ? '1' : '0'), \
                            (byte & 0x40 ? '1' : '0'), \
                            (byte & 0x20 ? '1' : '0'), \
                            (byte & 0x10 ? '1' : '0'), \
                            (byte & 0x08 ? '1' : '0'), \
                            (byte & 0x04 ? '1' : '0'), \
                            (byte & 0x02 ? '1' : '0'), \
                            (byte & 0x01 ? '1' : '0')


// TYPEDEFS
typedef struct {
  uint32_t buffer_addr;
  uint32_t buffer_size;
} pru1_config_t;


// GLOBALS
static const char* pin_mapping[] = { PIN_NAMES };
static bool  running = true;


// FUNCTIONS

static void sig_handler(int sig_num)
{
  // signal generated by stop function
  if (sig_num == SIGTERM) {
    running = false;
  }

  // signal generated by interactive user (ctrl+C)
  if (sig_num == SIGINT) {
#if INTERACTIVE_MODE
    printf("\b\b  \naborting...\n");
#endif /* INTERACTIVE_MODE */
    running = false;
  }
}


int register_sighandler(void)
{
  struct sigaction signal_action;
  signal_action.sa_handler = sig_handler;
  sigemptyset(&signal_action.sa_mask);
  signal_action.sa_flags = 0;
  if (sigaction(SIGTERM, &signal_action, NULL) < 0 ||
      sigaction(SIGINT, &signal_action, NULL) < 0) {
    printf("can't register signal handler\n");
    return 1;
  }
  return 0;
}


void wait_for_start(unsigned long starttime)
{
  //struct timespec currtime;
  unsigned long currtime = time(NULL);
  
  if (!starttime) {
    return;
  }
  
#if INTERACTIVE_MODE
  printf("waiting for start time... (%lus)\n", (starttime - time(NULL)));
  fflush(stdout);
#endif /* INTERACTIVE_MODE */
  starttime--;
  
  while (currtime && (currtime < starttime)) {
    // alternatively, use clock_gettime(CLOCK_REALTIME, &currtime)
    currtime = time(NULL);
    usleep(100000);
  }
}


int pru1_init(uint8_t** out_buffer_addr)
{
  static pru1_config_t prucfg;
  
  // initialize and open PRU device
  prussdrv_init();
  // note: for some reason, EVTOUT_1 corresponds to event 4 (should be event 3 according to manual)
  if (prussdrv_open(PRU_EVTOUT_1) != 0) {
    printf("failed to open PRUSS driver\n");
    return 1;
  }
  // setup PRU interrupt mapping
  tpruss_intc_initdata pruss_intc_initdata = PRUSS_INTC_INITDATA;
  prussdrv_pruintc_init(&pruss_intc_initdata);
  
  // PRU SETUP
  prucfg.buffer_size = BUFFER_SIZE;
  
#if INTERACTIVE_MODE
  printf("buffer size is %u bytes\n", BUFFER_SIZE);
#endif /* INTERACTIVE_MODE */

  // get buffers
  void *pru_extmem_base;
  prussdrv_map_extmem(&pru_extmem_base);
  prucfg.buffer_addr = (uint32_t)prussdrv_get_phys_addr(pru_extmem_base);

  // check max PRU buffer size
  uint32_t pru_extmem_size = (uint32_t)prussdrv_extmem_size();
  uint32_t pru_extmem_size_demand = BUFFER_SIZE;
  if (pru_extmem_size_demand > pru_extmem_size) {
    printf("insufficient PRU memory allocated/available.\nupdate uio_pruss configuration: options uio_pruss extram_pool_sz=0x%06x\n", pru_extmem_size_demand);
    return 2;
  }
  
  // get user space mapped PRU memory addresses
  if (out_buffer_addr) {
    *out_buffer_addr = prussdrv_get_virt_addr(prucfg.buffer_addr);
    if (!*out_buffer_addr) {
      printf("failed to get virtual address");
      return 3;
    }
    // clear buffer
    memset(*out_buffer_addr, 0, BUFFER_SIZE);
  }

  // write configuration to PRU data memory
  prussdrv_pru_write_memory(PRUSS0_PRU1_DATARAM, 0x0, (unsigned int *)&prucfg, sizeof(prucfg));

  // PRU memory write fence
  __sync_synchronize();

  // load the PRU firmware (requires a binary file)
  if (prussdrv_exec_program(1, PRU1_FIRMWARE) < 0) {
    printf("failed to start PRU (invalid or inexisting firmware file '%s')\n", PRU1_FIRMWARE);
    return 4;
  }
  
#if INTERACTIVE_MODE
  printf("firmware loaded\n");
  fflush(stdout);
#endif /* INTERACTIVE_MODE */
  
  return 0;
}


void pru1_deinit(void)
{
  // deinit
  prussdrv_pru_disable(0);
  prussdrv_exit();
}


int pru1_handshake(void)
{
  // signal PRU by setting the status bit (R31.t31)
  prussdrv_pru_send_event(ARM_PRU1_INTERRUPT);
  
  // wait for PRU event (returns 0 on timeout, -1 on error with errno)
  int res = prussdrv_pru_wait_event_timeout(PRU_EVTOUT_1, 2000000);   /* 2s */
  if (res < 0) {
    // error checking interrupt occurred
    printf("failed waiting for PRU interrupt\n");
    return 1;
  } else if (res == 0) {
    printf("failed to start PRU (not responding)\n");
    return 2;
  }

  // clear event
  prussdrv_pru_clear_event(PRU_EVTOUT_1, PRU1_ARM_INTERRUPT);
  
  return 0;
}


int pru1_sample(uint8_t* pru_buffer, FILE* data_file)
{
  uint32_t readout_count = 0;
  int res;
  
  if (!pru_buffer || !data_file) {
    return 1;
  }

  // start sampling
#if INTERACTIVE_MODE
  printf("starting sampling loop... (press ctrl+c to abort)\n");
  fflush(stdout);
#endif /* INTERACTIVE_MODE */
  
  // continuous sampling loop
  while (running) {
    // wait for PRU event indicating new data (repeat wait on interrupts)
    do {
      // wait for PRU event (returns 0 on timeout, -1 on error with errno)
      res = prussdrv_pru_wait_event_timeout(PRU_EVTOUT_1, 1000000);
    } while (res < 0 && errno == EINTR);
    if (res < 0) {
      // error checking interrupt occurred
      printf("failed waiting for PRU interrupt\n");
      break;
    } else if (res == 0) {
      // timeout -> just continue
      continue;
    }
    // clear event
    prussdrv_pru_clear_event(PRU_EVTOUT_1, PRU1_ARM_INTERRUPT);

    // PRU memory sync before accessing data
    __sync_synchronize();

    uint8_t* curr_buffer = (uint8_t*)pru_buffer;
    if (readout_count & 1) {
      // odd numbers
      curr_buffer = (uint8_t*)&pru_buffer[BUFFER_SIZE / 2];
    }
#if INTERACTIVE_MODE
    // display latest value
    unsigned char curr_value = *(uint8_t*)(curr_buffer + (BUFFER_SIZE / 2) - 4);
    printf("\b\b\b\b\b\b\b\b" BYTE_TO_BIN_PATTERN, BYTE_TO_BIN(curr_value));
    fflush(stdout);
#endif /* INTERACTIVE_MODE */
    
    // write to file
    fwrite(curr_buffer, (BUFFER_SIZE / 2), 1, data_file);

    // clear buffer
    memset(curr_buffer, 0, (BUFFER_SIZE / 2));
    
    readout_count++;
  }
  // copy the remaining data
  if (readout_count & 1) {
    fwrite(&pru_buffer[BUFFER_SIZE / 2], (BUFFER_SIZE / 2), 1, data_file);
  } else {
    fwrite(pru_buffer, (BUFFER_SIZE / 2), 1, data_file);
  }
  
#if INTERACTIVE_MODE
  printf("stored %u samples to file\n", readout_count * BUFFER_SIZE / 8);
#endif /* INTERACTIVE_MODE */

  return res;
}


// convert binary tracing data to a csv file
void parse_tracing_data(const char* filename, unsigned long starttime)
{
  char     buffer[SPRINTF_BUFFER_LENGTH];
  FILE*    data_file   = NULL;
  FILE*    csv_file    = NULL;
  uint32_t sample      = 0;
  uint32_t prev_sample = 0xffffffff;
  uint32_t line_cnt    = 0;
  uint32_t sample_cnt  = 0;
  uint64_t timestamp   = 0;
  
  data_file = fopen(filename, "rb");      // binary mode
  sprintf(buffer, "%s.csv", filename);
  csv_file = fopen(buffer, "w");          // text mode
  if (NULL == data_file || NULL == csv_file) {
    printf("failed to open files\n");
    return;
  }
  // parse and write data
  while (fread(&sample, 4, 1, data_file)) {
    if (prev_sample == 0xffffffff) {
      prev_sample = ~sample & 0xff;
    }
    // data valid? -> at least the cycle counter must be > 0
    if (sample == 0) {
#if INTERACTIVE_MODE
      long int pos = ftell(data_file);
      fseek(data_file, 0, SEEK_END);
      long int size = ftell(data_file);
      printf("invalid sample detected, aborting conversion (current position: %ld/%ld)", pos, size);
#endif /* INTERACTIVE_MODE */
      break;
    }
    // update the timestamp
    timestamp += (sample >> 8);
    double currtime = (double)starttime + (double)timestamp / SAMPLING_RATE;
    // go through all pins and check whether there has been a change
    uint32_t i = 0;
    while (i < 8) {
      if ((prev_sample & (1 << i)) != (sample & (1 << i))) {
        // format: timestamp,obs_id,node_id,pin,state(0/1)
        sprintf(buffer, "%.7f,%s,%u\r\n", currtime, pin_mapping[i], (sample & (1 << i)) > 0);
        fwrite(buffer, strlen(buffer), 1, csv_file);
        line_cnt++;
      }
      i++;
    }
    prev_sample = sample;
    sample_cnt++;
  }
  fclose(data_file);
  fclose(csv_file);
#if INTERACTIVE_MODE
  printf("tracing data parsed and stored in %s.csv (%u samples, %u lines)\n", filename, sample_cnt, line_cnt);
#endif /* INTERACTIVE_MODE */
}


// MAIN
int main(int argc, char** argv)
{
  FILE*    datafile = NULL;
  uint8_t* prubuffer = NULL;
  char     filename[SPRINTF_BUFFER_LENGTH];
  long int starttime = 0;
  
  // get arguments
  if (argc > 2) {
    // 2nd argument is always the start timestamp
    starttime = strtol(argv[2], NULL, 10);
  }
  // generate filename and create output directory
  if (argc > 1) {
    // 1st argument is always the filename
    strncpy(filename, argv[1], SPRINTF_BUFFER_LENGTH);
    char* tmp = strrchr(argv[1], '/');
    if (tmp) tmp[0] = 0;
    if (mkdir(argv[1], 0777) == 0) {
      printf("output directory %s created\n", argv[1]);
    }
  } else {
    if (mkdir(OUTPUT_DIR, 0777) == 0) {
      printf("output directory %s created\n", OUTPUT_DIR);
    }
    sprintf(filename, OUTPUT_DIR "%s_%lu.dat", DATA_FILENAME_PREFIX, time(NULL));
  }
  
  // register signal handler for SIGTERM and SIGINT (for stopping)
  if (register_sighandler() != 0) {
    return 1;
  }
  
  // open output file
  datafile = fopen(filename, "wb");
  if (NULL == datafile) {
    printf("failed to open file %s\n", filename);
    pru1_deinit();
    return 2;
  }
  
  // setup
  if (pru1_init(&prubuffer) != 0) {
    fclose(datafile);
    return 3;
  }
  
  // if start time is given, wait for it
  wait_for_start(starttime);
  
  // handshake with PRU (synchronize)
  if (pru1_handshake() != 0) {
    printf("handshake failed\n");
    fclose(datafile);
    return 4;
  }
  
  // start sampling
  if (pru1_sample(prubuffer, datafile) != 0) {
    printf("an error occurred\n");
  }
  
  // cleanup
  pru1_deinit();
  
  fflush(datafile);
  fclose(datafile);
#if INTERACTIVE_MODE
  printf("samples stored in %s\n", filename);
#endif /* INTERACTIVE_MODE */
  
  // parse data
  parse_tracing_data(filename, starttime);
  
#if INTERACTIVE_MODE
  printf("terminated\n");
#endif /* INTERACTIVE_MODE */
  
  return 0;
}
