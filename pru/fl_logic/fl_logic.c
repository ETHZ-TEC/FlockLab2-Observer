/**
 * Copyright (c) 2016-2019, ETH Zurich, Computer Engineering Group
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

// INCLUDES
#include <errno.h>
#include <stdbool.h>
#include <string.h>
#include <stdio.h>
#include <stdint.h>
#include <signal.h>
#include <pruss_intc_mapping.h>
#include <prussdrv.h>
#include <time.h>
#include <sys/stat.h>

//#include "gpio.h"

// DEFINES
#define BUFFER_SIZE           8                     // in bytes (must be a power of 2, minimum is 8 bytes)
#define SAMPLING_RATE         1000
#define MAX_READOUT_CNT       1000
#define PRU1_FIRMWARE         "/lib/firmware/fl_pru1_logic.bin"     // must be a binary file
#define DATA_FILENAME_PREFIX  "tracing_data"
#define OUTPUT_DIR            "/home/flocklab/data/"                // with last slash
#define SPRINTF_BUFFER_LENGTH 256
#define CSV_FILE_HDR          "# timestamp,observer_id,node_id,pin_name,value\r\n"
#define OBSERVER_ID           1
#define PIN_NAMES             "LED1", "LED2", "LED3", "INT1", "INT2", "SIG1", "SIG2", "nRST"

// PARAMETER CHECK
#if (BUFFER_SIZE & (BUFFER_SIZE - 1)) || (BUFFER_SIZE < 8)
#error "invalid BUFFER_SIZE"
#endif

// MACROS
#define BYTE_TO_BIN_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BIN(byte)   (byte & 0x80 ? '1' : '0'), \
                            (byte & 0x40 ? '1' : '0'), \
                            (byte & 0x20 ? '1' : '0'), \
                            (byte & 0x10 ? '1' : '0'), \
                            (byte & 0x08 ? '1' : '0'), \
                            (byte & 0x04 ? '1' : '0'), \
                            (byte & 0x02 ? '1' : '0'), \
                            (byte & 0x01 ? '1' : '0')

// TYPEDEFS
typedef struct {
  uint32_t buffer_addr;
  uint32_t buffer_size;
  uint32_t sampling_rate;
} pru1_config_t;

// GLOBALS
static const char* pin_mapping[] = { PIN_NAMES };
static bool  running = true;

// FUNCTIONS
static void sig_handler(int sig_num)
{
  // signal generated by stop function
  if (sig_num == SIGTERM) {
    //printf("SIGTERM received\n");
    running = false;
  }

  // signal generated by interactive user (ctrl+C)
  if (sig_num == SIGINT) {
    printf("\b\b  \naborting...\n");
    running = false;
  }
}

int pru1_run(FILE* data_file)
{
  static pru1_config_t prucfg;
  int res;

  // PRU SETUP
  prucfg.buffer_size = BUFFER_SIZE;
  prucfg.sampling_rate = SAMPLING_RATE;
  
  printf("buffer size is %u bytes\n", BUFFER_SIZE);

  // get buffers
  void *pru_extmem_base;
  prussdrv_map_extmem(&pru_extmem_base);
  prucfg.buffer_addr = (uint32_t)prussdrv_get_phys_addr(pru_extmem_base);

  // check max PRU buffer size
  uint32_t pru_extmem_size = (uint32_t)prussdrv_extmem_size();
  uint32_t pru_extmem_size_demand = BUFFER_SIZE;
  if (pru_extmem_size_demand > pru_extmem_size) {
    printf("insufficient PRU memory allocated/available.\nupdate uio_pruss configuration: options uio_pruss extram_pool_sz=0x%06x\n", pru_extmem_size_demand);
    return -1;
  }
  
  // get user space mapped PRU memory addresses
  uint8_t const *buffer = prussdrv_get_virt_addr(prucfg.buffer_addr);

  // write configuration to PRU data memory
  prussdrv_pru_write_memory(PRUSS0_PRU1_DATARAM, 0x0, (unsigned int *)&prucfg, sizeof(prucfg));

  // PRU memory write fence
  __sync_synchronize();

  res = prussdrv_exec_program(1, PRU1_FIRMWARE);  // requires a binary file
  if (res < 0) {
    printf("failed to start PRU (invalid or inexisting firmware file '%s')\n", PRU1_FIRMWARE);
    return -2;
  }
  printf("firmware loaded\n");
  fflush(stdout);

  // signal PRU by setting the status bit (R31.t31)
  prussdrv_pru_send_event(ARM_PRU1_INTERRUPT);
  
  // wait for PRU event (returns 0 on timeout, -1 on error with errno)
  res = prussdrv_pru_wait_event_timeout(PRU_EVTOUT_1, 2000000);   /* 2s */
  if (res < 0) {
    // error checking interrupt occurred
    printf("failed waiting for PRU interrupt\n");
    return -3;
  } else if (res == 0) {
    printf("failed to start PRU (not responding)\n");
    return -4;
  }

  // clear event
  prussdrv_pru_clear_event(PRU_EVTOUT_1, PRU1_ARM_INTERRUPT);

  printf("starting sampling loop... (press ctrl+c to abort)\n");
  fflush(stdout);
  
  uint32_t readout_count = 0;
  unsigned char curr_value = 0;
  // continuous sampling loop
  while ((readout_count < MAX_READOUT_CNT) && running) {
    // wait for PRU event indicating new data (repeat wait on interrupts)
    do {
      // wait for PRU event (returns 0 on timeout, -1 on error with errno)
      res = prussdrv_pru_wait_event_timeout(PRU_EVTOUT_1, 1000000);
    } while (res < 0 && errno == EINTR);
    if (res < 0) {
      // error checking interrupt occurred
      printf("failed waiting for PRU interrupt\n");
      break;
    } else if (res == 0) {
      // timeout -> just continue
      continue;
    }
    // clear event
    prussdrv_pru_clear_event(PRU_EVTOUT_1, PRU1_ARM_INTERRUPT);

    // PRU memory sync before accessing data
    __sync_synchronize();

    uint8_t* curr_buffer = (uint8_t*)buffer;
    if (readout_count & 1) {
      // odd numbers
      curr_buffer = (uint8_t*)&buffer[BUFFER_SIZE / 2];
    }
    // display latest value
    curr_value = *(uint8_t*)(curr_buffer + (BUFFER_SIZE / 2) - 4);
    printf("\b\b\b\b\b\b\b\b" BYTE_TO_BIN_PATTERN, BYTE_TO_BIN(curr_value));
    fflush(stdout);
    
    // write to file
    if (data_file) {
      fwrite(curr_buffer, (BUFFER_SIZE / 2), 1, data_file);
    }
    
    readout_count++;
  }
  
  printf("stored %u samples to file\n", readout_count * BUFFER_SIZE / 8);

  return 0;
}

// convert binary tracing data to a csv file
void parse_tracing_data(const char* filename)
{
  char  buffer[SPRINTF_BUFFER_LENGTH];
  FILE* data_file = NULL;
  FILE* csv_file  = NULL;
  uint32_t sample = 0;
  uint32_t prev_sample = 0xffffffff;
  uint32_t line_cnt = 0;
  uint32_t sample_cnt = 0;
  uint64_t timestamp = 0.0;
  
  data_file = fopen(filename, "rb");      // binary mode
  sprintf(buffer, "%s.xml", filename);
  csv_file = fopen(buffer, "w");          // text mode
  if (NULL == data_file || NULL == csv_file) {
    printf("failed to open files\n");
    return;
  }
  // write header
  fwrite(CSV_FILE_HDR, sizeof(CSV_FILE_HDR), 1, csv_file);
  // parse and write data
  while (fread(&sample, 4, 1, data_file)) {
    if (prev_sample == 0xffffffff) {
      prev_sample = ~sample & 0xff;
    }
    // go through all pins and check whether there has been a change
    uint32_t i = 0;
    while (i < 8) {
      if ((prev_sample & (1 << i)) != (sample & (1 << i))) {
        // format: timestamp,obs_id,node_id,pin,state(0/1)
        sprintf(buffer, "%.7f,%u,%u,%s,%u\r\n", (double)timestamp / SAMPLING_RATE, OBSERVER_ID, OBSERVER_ID, pin_mapping[i], (sample & (1 << i)) > 0);
        fwrite(buffer, strlen(buffer), 1, csv_file);
        line_cnt++;
      }
      i++;
    }
    prev_sample = sample;
    timestamp += (sample >> 8);
    sample_cnt++;
  }
  fclose(data_file);
  fclose(csv_file);
  printf("tracing data parsed and stored in %s.xml (%u samples, %u lines)\n", filename, sample_cnt, line_cnt);
}

int main(void)
{
  char filename[SPRINTF_BUFFER_LENGTH];
  int  ret;
  
  printf("initializing...\n");
  
  // register signal handler for SIGTERM and SIGINT (for stopping)
  struct sigaction signal_action;
  signal_action.sa_handler = sig_handler;
  sigemptyset(&signal_action.sa_mask);
  signal_action.sa_flags = 0;
  if (sigaction(SIGTERM, &signal_action, NULL) < 0 ||
      sigaction(SIGINT, &signal_action, NULL) < 0) {
    printf("can't register signal handler\n");
    return 1;
  }
  
  // init
  /*gpio_init(GPIO_LED_STATUS, GPIO_MODE_OUT);
  gpio_init(GPIO_LED_ERROR, GPIO_MODE_OUT);
  gpio_set_value(GPIO_LED_STATUS, 1);
  gpio_set_value(GPIO_LED_ERROR, 0);*/

  // initialize and open PRU device
  prussdrv_init();
  ret = prussdrv_open(PRU_EVTOUT_1);  // for some reason, EVTOUT_1 corresponds to event 4 (should be event 3 according to manual)
  if (ret != 0) {
    printf("failed to open PRUSS driver\n");
    return -1;
  }
  // setup PRU interrupt mapping
  tpruss_intc_initdata pruss_intc_initdata = PRUSS_INTC_INITDATA;
  prussdrv_pruintc_init(&pruss_intc_initdata);
  
  // create/open file
  mkdir(OUTPUT_DIR, 0777);   // create directory
  sprintf(filename, OUTPUT_DIR "%s_%lu.dat", DATA_FILENAME_PREFIX, time(NULL));
  FILE* data_file = fopen(filename, "wb");
  if (NULL == data_file) {
    printf("failed to open file %s\n", filename);
  } else {
    // start sampling
    ret = pru1_run(data_file);
    if (ret < 0) {
      printf("an error occurred\n");
    }
    fflush(data_file);
    fclose(data_file);
    printf("samples stored in %s\n", filename);
  }
  
  // deinit
  prussdrv_pru_disable(0);
  prussdrv_exit();
  
  // parse data
  parse_tracing_data(filename);
  
  printf("terminated\n");
  
  return 0;
}
